#!/usr/bin/env python3
# weather_server.py — returns temperature **and** conditions
#
# Added robustness:
#   • get_weather() now retries the Open-Meteo call up to MAX_RETRIES times
#     with exponential back-off if it hits a network error or 429/5xx status.
#   • The retry logic keeps the overall behaviour identical for normal cases,
#     but shields the agent from transient API-quota failures.

from __future__ import annotations

import time
from typing import Final

import requests
from fastmcp import FastMCP
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# ───────────────────────── weather-code → description ─────────────────────
WEATHER_CODES: Final[dict[int, str]] = {
    0:  "Clear sky",                     1:  "Mainly clear",
    2:  "Partly cloudy",                 3:  "Overcast",
    45: "Fog",                           48: "Depositing rime fog",
    51: "Light drizzle",                 53: "Moderate drizzle",
    55: "Dense drizzle",                 56: "Light freezing drizzle",
    57: "Dense freezing drizzle",        61: "Slight rain",
    63: "Moderate rain",                 65: "Heavy rain",
    66: "Light freezing rain",           67: "Heavy freezing rain",
    71: "Slight snow fall",              73: "Moderate snow fall",
    75: "Heavy snow fall",               77: "Snow grains",
    80: "Slight rain showers",           81: "Moderate rain showers",
    82: "Violent rain showers",          85: "Slight snow showers",
    86: "Heavy snow showers",            95: "Thunderstorm",
    96: "Thunderstorm with slight hail", 99: "Thunderstorm with heavy hail",
}

# ───────────────────── retry-aware requests Session ──────────────────────
MAX_RETRIES      = 3      # total attempts (initial + 2 retries)
BACKOFF_FACTOR   = 1.5    # exponential delay multiplier (1.5s, 2.25s, …)
STATUS_RETRY_SET = {429, 500, 502, 503, 504}

retry_strategy = Retry(
    total=MAX_RETRIES - 1,                # urllib3 counts *retries*, not attempts
    backoff_factor=BACKOFF_FACTOR,
    status_forcelist=list(STATUS_RETRY_SET),
    allowed_methods=["GET"],
    raise_on_status=False,                # we'll raise manually after retries
)

session = requests.Session()
session.mount("https://", HTTPAdapter(max_retries=retry_strategy))

# ──────────────────────── instantiate MCP server ─────────────────────────
mcp = FastMCP("WeatherServer")

# ───────────────────────────── tools ─────────────────────────────────────
@mcp.tool
def get_weather(lat: float, lon: float) -> dict:
    """
    Current conditions via Open-Meteo, resilient to transient quota errors.

        {
            "temperature": °C,
            "code":        int,   # Open-Meteo weathercode
            "conditions":  str    # human-readable description
        }
    """
    url = (
        "https://api.open-meteo.com/v1/forecast"
        f"?latitude={lat}&longitude={lon}&current_weather=true"
    )

    for attempt in range(1, MAX_RETRIES + 1):
        try:
            resp = session.get(url, timeout=15)
            if resp.status_code in STATUS_RETRY_SET:
                raise requests.HTTPError(f"{resp.status_code} from Open-Meteo")
            resp.raise_for_status()
            cw = resp.json()["current_weather"]
            code = cw["weathercode"]
            return {
                "temperature": cw["temperature"],
                "code":        code,
                "conditions":  WEATHER_CODES.get(code, "Unknown"),
            }
        except (requests.RequestException, KeyError, ValueError) as exc:
            # Only retry on transient issues; permanent failures break early.
            if attempt == MAX_RETRIES:
                raise
            sleep_seconds = BACKOFF_FACTOR ** (attempt - 1)
            time.sleep(sleep_seconds)
            continue  # next retry

@mcp.tool
def convert_c_to_f(c: float) -> float:
    """Convert Celsius to Fahrenheit."""
    return c * 9 / 5 + 32

# ─────────────────────────── run server ────────────────────────────
if __name__ == "__main__":
    # JSON-RPC on /mcp/  (streaming also auto-published on /streamable-http)
    mcp.run(
        transport="http",
        host="127.0.0.1",
        port=8000,
        path="/mcp/",
    )
